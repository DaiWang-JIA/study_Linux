# 进程和线程

## 进程组和会话

- 进程聚集称为进程组，多个进程组聚集称为会话

![image-20250628191727457](进程和线程.assets/image-20250628191727457.png)

- ps ajx 查看进程组id和会话id

- 创建会话

![image-20250628192705360](进程和线程.assets/image-20250628192705360.png)

- getsid函数

![image-20250628193102656](进程和线程.assets/image-20250628193102656.png)

- ==setsid==

![image-20250628193139024](进程和线程.assets/image-20250628193139024.png)

![image-20250628193314803](进程和线程.assets/image-20250628193314803.png)

![image-20250628193428064](进程和线程.assets/image-20250628193428064.png)





## 守护进程

### 守护进程概念

![image-20250628194846327](进程和线程.assets/image-20250628194846327.png)

### 创建守护进程

![image-20250628195058177](进程和线程.assets/image-20250628195058177.png)

- 代码：

![image-20250628200616274](进程和线程.assets/image-20250628200616274.png)

![image-20250628200551766](进程和线程.assets/image-20250628200551766.png)



# 线程

## 线程的概念

![image-20250630095940336](进程和线程.assets/image-20250630095940336.png)

![image-20250630100155953](进程和线程.assets/image-20250630100155953.png)

![image-20250630100943396](进程和线程.assets/image-20250630100943396.png)

## 线程内核实现原理

* 三级映射

![image-20250701151741662](进程和线程.assets/image-20250701151741662.png)



## 线程共享

![image-20250701161751911](进程和线程.assets/image-20250701161751911.png)



## 线程优缺点

![image-20250701161706155](进程和线程.assets/image-20250701161706155.png)

![image-20250701161947648](进程和线程.assets/image-20250701161947648.png)



## 线程控制原语

### 获取线程ID

![image-20250701165012169](进程和线程.assets/image-20250701165012169.png)

### 创建线程

![image-20250701165337541](进程和线程.assets/image-20250701165337541.png)

![image-20250701165537346](进程和线程.assets/image-20250701165537346.png)

## 创建子线程

![image-20250701170358216](进程和线程.assets/image-20250701170358216.png)



## 循环创建子线程

![image-20250701171604514](进程和线程.assets/image-20250701171604514.png)



## 线程退出

![image-20250701180207587](进程和线程.assets/image-20250701180207587.png)

![image-20250701175807465](进程和线程.assets/image-20250701175807465.png)

![image-20250701175850418](进程和线程.assets/image-20250701175850418.png)



## pthread_join回收线程退出值

![image-20250701180506419](进程和线程.assets/image-20250701180506419.png)

- 示例一：

![image-20250701182452244](进程和线程.assets/image-20250701182452244.png)

![image-20250701182524309](进程和线程.assets/image-20250701182524309.png)

- 示例二：

![image-20250701183224001](进程和线程.assets/image-20250701183224001.png)

![image-20250701183204663](进程和线程.assets/image-20250701183204663.png)



## pthread_detach线程分离

![image-20250701185353406](进程和线程.assets/image-20250701185353406.png)



## 杀死（取消）线程

![image-20250701190307427](进程和线程.assets/image-20250701190307427.png)

![image-20250701190910056](进程和线程.assets/image-20250701190910056.png)



## 终止线程的方法

![image-20250701191102597](进程和线程.assets/image-20250701191102597.png)

![image-20250701191007247](进程和线程.assets/image-20250701191007247.png)



## 线程进程终止原语对比

![image-20250701191250743](进程和线程.assets/image-20250701191250743.png)









# 线程同步

- 同步：即协同步调，按预定的先后次序访问共享数据。
- 线程同步，指一个线程发出某一个功能调用时，没有得到结果之前，该调用不返回。同时，其他线程为保证数据一致性，不调用改功能。

![image-20250702131324868](进程和线程.assets/image-20250702131324868.png)

-  数据混乱产生的原因：

![image-20250702131636009](进程和线程.assets/image-20250702131636009.png)

- 只能从第三步着手解决“数据混乱”，避免产生与时间有关的错误。执行多个控制流（线程）访问共享的数据的先后顺序

- 锁的属性：

![image-20250702132754119](进程和线程.assets/image-20250702132754119.png)



## 互斥量（互斥锁）

- 函数：

![image-20250702134146914](进程和线程.assets/image-20250702134146914.png)

示例：

![image-20250702134653007](进程和线程.assets/image-20250702134653007.png)

![image-20250702134808097](进程和线程.assets/image-20250702134808097.png)

![image-20250702134839032](进程和线程.assets/image-20250702134839032.png)

- 注意事项

![image-20250702135930705](进程和线程.assets/image-20250702135930705.png)

- 互斥量初始化方法：

![image-20250702140146519](进程和线程.assets/image-20250702140146519.png)



## 死锁

- 不是一种锁！ 是错误使用锁的一种状态。

- 常见死锁种类：

![image-20250702142406979](进程和线程.assets/image-20250702142406979.png)

![image-20250702143219252](进程和线程.assets/image-20250702143219252.png)



## 读写锁

==3句话描述==

![image-20250702143542354](进程和线程.assets/image-20250702143542354.png)

若读锁已经加锁成功，写锁无法加锁

![image-20250702144449105](进程和线程.assets/image-20250702144449105.png)

- 相较于互斥锁，读写锁非常适合于对数据结构的操作次数，远大于写的操作次数的场景

==函数：==

![image-20250702145748522](进程和线程.assets/image-20250702145748522.png)

![image-20250702145805976](进程和线程.assets/image-20250702145805976.png)



==读写锁使用示例：==

![image-20250702150137466](进程和线程.assets/image-20250702150137466.png)

![image-20250702150429997](进程和线程.assets/image-20250702150429997.png)

![image-20250702150524260](进程和线程.assets/image-20250702150524260.png)



## 条件变量

![image-20250702152328899](进程和线程.assets/image-20250702152328899.png)

==函数：==

![image-20250702155449645](进程和线程.assets/image-20250702155449645.png)

![image-20250702155717947](进程和线程.assets/image-20250702155717947.png)



## 生产消费者模型

 ![image-20250702160556680](进程和线程.assets/image-20250702160556680.png)

代码：

![image-20250702160708258](进程和线程.assets/image-20250702160708258.png)

![image-20250702160851353](进程和线程.assets/image-20250702160851353.png)

![image-20250702162004368](进程和线程.assets/image-20250702162004368.png)

![image-20250702160956512](进程和线程.assets/image-20250702160956512.png)

![image-20250702162849076](进程和线程.assets/image-20250702162849076.png)

- 多生产者消费者

![image-20250702172215530](进程和线程.assets/image-20250702172215530.png)



## 信号量（semaphore）

![image-20250702175050892](进程和线程.assets/image-20250702175050892.png)

==函数：==

![image-20250702181321681](进程和线程.assets/image-20250702181321681.png)

![image-20250702181339873](进程和线程.assets/image-20250702181339873.png)
